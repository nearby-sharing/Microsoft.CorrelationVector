// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

using System;
using System.Globalization;
using System.Threading;

namespace Microsoft.CorrelationVector;

/// <summary>
/// This class represents version 2 of the cV, a lightweight vector for identifying and measuring
/// causality.
/// </summary>
public sealed class CorrelationVectorV2 : CorrelationVector
{
    internal new const byte MaxVectorLength = 127;
    internal const byte BaseLength = 22;

    internal readonly string BaseVector = null;

    private int extension = 0;

    private bool immutable = false;

    /// <summary>
    /// This is the termination sign which should be used when vector length exceeds 
    /// the <see cref="MaxVectorLength"/>
    /// </summary>
    public const string TerminationSign = "!";

    /// <summary>
    /// Creates a new correlation vector by extending an existing value. This should be
    /// done at the entry point of an operation.
    /// </summary>
    /// <param name="correlationVector">
    /// Taken from the message header indicated by <see cref="HeaderName"/>.
    /// </param>
    /// <returns>A new correlation vector extended from the current vector.</returns>
    public new static CorrelationVectorV2 Extend(string correlationVector)
    {
        if (CorrelationVectorV2.IsImmutable(correlationVector))
        {
            return CorrelationVectorV2.Parse(correlationVector);
        }

        if (CorrelationVectorV2.ValidateCorrelationVectorDuringCreation)
        {
            CorrelationVectorV2.Validate(correlationVector);
        }

        if (CorrelationVectorV2.IsOversized(correlationVector, 0))
        {
            return CorrelationVectorV2.Parse(correlationVector + CorrelationVectorV2.TerminationSign);
        }

        return new CorrelationVectorV2(correlationVector, 0, false);
    }

    /// <summary>
    /// Creates a new correlation vector by applying the Spin operator to an existing value.
    /// This should be done at the entry point of an operation.
    /// </summary>
    /// <param name="correlationVector">
    /// Taken from the message header indicated by <see cref="HeaderName"/>.
    /// </param>
    /// <param name="parameters">
    /// The parameters to use when applying the Spin operator.
    /// </param>
    /// <returns>A new correlation vector extended from the current vector.</returns>
    public new static CorrelationVectorV2 Spin(string correlationVector, SpinParameters parameters)
    {
        if (CorrelationVectorV2.IsImmutable(correlationVector))
        {
            return CorrelationVectorV2.Parse(correlationVector);
        }

        if (CorrelationVectorV2.ValidateCorrelationVectorDuringCreation)
        {
            CorrelationVectorV2.Validate(correlationVector);
        }

        byte[] entropy = new byte[parameters.EntropyBytes];
        Random.Shared.NextBytes(entropy);

        ulong value = (ulong)(DateTime.UtcNow.Ticks >> parameters.TicksBitsToDrop);
        for (int i = 0; i < parameters.EntropyBytes; i++)
        {
            value = (value << 8) | Convert.ToUInt64(entropy[i]);
        }

        // Generate a bitmask and mask the lower TotalBits in the value.
        // The mask is generated by (1 << TotalBits) - 1. We need to handle the edge case
        // when shifting 64 bits, as it wraps around.
        value &= (parameters.TotalBits == 64 ? 0 : (ulong)1 << parameters.TotalBits) - 1;

        string s = unchecked((uint)value).ToString();
        if (parameters.TotalBits > 32)
        {
            s = string.Concat((value >> 32).ToString(), ".", s);
        }

        string baseVector = string.Concat(correlationVector, ".", s);
        if (CorrelationVectorV2.IsOversized(baseVector, 0))
        {
            return CorrelationVectorV2.Parse(correlationVector + CorrelationVectorV2.TerminationSign);
        }

        return new CorrelationVectorV2(baseVector, 0, false);
    }

    /// <summary>
    /// Creates a new correlation vector by parsing its string representation
    /// </summary>
    /// <param name="correlationVector">correlationVector</param>
    /// <returns>CorrelationVector</returns>
    public new static CorrelationVectorV2 Parse(string correlationVector)
    {
        if (!string.IsNullOrEmpty(correlationVector))
        {
            int p = correlationVector.LastIndexOf('.');
            bool immutable = CorrelationVectorV2.IsImmutable(correlationVector);
            if (p > 0)
            {
                string extensionValue = immutable ? correlationVector.Substring(p + 1, correlationVector.Length - p - 1 - CorrelationVectorV2.TerminationSign.Length)
                    : correlationVector[(p + 1)..];
                if (int.TryParse(extensionValue, out int extension) && extension >= 0)
                {
                    return new CorrelationVectorV2(correlationVector[..p], extension, immutable);
                }
            }
        }

        return new CorrelationVectorV2();
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CorrelationVectorV2"/> class. 
    /// This should only be called when no correlation
    /// vector was found in the message header.
    /// </summary>
    public CorrelationVectorV2()
        : this(CorrelationVectorV2.GetUniqueValue(), 0, false)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CorrelationVectorV2"/> class
    /// using the given <see cref="System.Guid"/> as the vector base.
    /// </summary>
    /// <param name="vectorBase">The <see cref="System.Guid"/> to use as a correlation
    /// vector base.</param>
    public CorrelationVectorV2(Guid vectorBase)
        : this(vectorBase.GetBaseFromGuid(BaseLength), 0, false)
    {
    }

    /// <summary>
    /// Gets the value of the correlation vector as a string.
    /// </summary>
    public override string Value
    {
        get
        {
            return string.Concat(this.BaseVector, ".", this.extension,
                this.immutable ? CorrelationVectorV2.TerminationSign : string.Empty);
        }
    }

    /// <summary>
    /// Increments the current extension by one. Do this before passing the value to an
    /// outbound message header.
    /// </summary>
    /// <returns>
    /// The new value as a string that you can add to the outbound message header
    /// indicated by <see cref="HeaderName"/>.
    /// </returns>
    public override string Increment()
    {
        if (this.immutable)
        {
            return this.Value;
        }
        int snapshot;
        int next;
        do
        {
            snapshot = this.extension;
            if (snapshot == int.MaxValue)
            {
                return this.Value;
            }
            next = snapshot + 1;
            if (CorrelationVectorV2.IsOversized(this.BaseVector, next))
            {
                this.immutable = true;
                return this.Value;
            }
        }
        while (snapshot != Interlocked.CompareExchange(ref this.extension, next, snapshot));
        return string.Concat(this.BaseVector, ".", next);
    }

    public override string Base
    {
        get
        {
            int firstDotLocation = Value.IndexOf('.');
            return Value[..firstDotLocation];
        }
    }

    public override int Extension
    {
        get
        {
            return this.extension;
        }
    }

    /// <summary>
    /// Returns a string that represents the current object.
    /// </summary>
    /// <returns>A string that represents the current object.</returns>
    public override string ToString()
    {
        return this.Value;
    }

    /// <summary>
    /// Determines whether two instances of the <see cref="CorrelationVectorV2"/> class
    /// are equal. 
    /// </summary>
    /// <param name="vector">
    /// The correlation vector you want to compare with the current correlation vector.
    /// </param>
    /// <returns>
    /// True if the specified correlation vector is equal to the current correlation
    /// vector; otherwise, false.
    /// </returns>
    public bool Equals(CorrelationVectorV2 vector)
    {
        return string.Equals(this.Value, vector.Value, StringComparison.Ordinal);
    }

    private CorrelationVectorV2(string baseVector, int extension, bool immutable)
    {
        this.BaseVector = baseVector;
        this.extension = extension;
        this.Version = CorrelationVectorVersion.V2;
        this.immutable = immutable || CorrelationVectorV2.IsOversized(baseVector, extension);
    }

    private static string GetUniqueValue()
    {
        return Guid.NewGuid().GetBaseFromGuid(BaseLength);
    }

    private static bool IsImmutable(string correlationVector)
    {
        return !string.IsNullOrEmpty(correlationVector) && correlationVector.EndsWith(CorrelationVectorV2.TerminationSign);
    }

    /// <summary>
    /// Checks if the cV will be too big if an extension is added to the base vector.
    /// </summary>
    /// <param name="baseVector"></param>
    /// <param name="extension"></param>
    /// <returns>True if new vector will be too large. False if there is no vector or the vector is the appropriate size.</returns>
    private static bool IsOversized(string baseVector, int extension)
    {
        if (!string.IsNullOrEmpty(baseVector))
        {
            int size = baseVector.Length + 1 +
                (extension > 0 ? (int)Math.Log10(extension) : 0) + 1;
            return size > MaxVectorLength;
        }
        return false;
    }

    private static void Validate(string correlationVector)
    {
        byte maxVectorLength;
        byte baseLength;
        maxVectorLength = CorrelationVectorV2.MaxVectorLength;
        baseLength = CorrelationVectorV2.BaseLength;

        if (string.IsNullOrWhiteSpace(correlationVector) || correlationVector.Length > maxVectorLength)
        {
            throw new ArgumentException(string.Format(CultureInfo.InvariantCulture,
                "The {0} correlation vector can not be null or bigger than {1} characters", CorrelationVectorVersion.V2, maxVectorLength));
        }

        string[] parts = correlationVector.Split('.');

        if (parts.Length < 2 || parts[0].Length != baseLength)
        {
            throw new ArgumentException(string.Format(CultureInfo.InvariantCulture, "Invalid correlation vector {0}. Invalid base value {1}", correlationVector, parts[0]));
        }

        for (int i = 1; i < parts.Length; i++)
        {
            if (int.TryParse(parts[i], out int result) == false || result < 0)
            {
                throw new ArgumentException(string.Format(CultureInfo.InvariantCulture, "Invalid correlation vector {0}. Invalid extension value {1}", correlationVector, parts[i]));
            }
        }
    }

    public override (string newVector, string oldVector) Reset()
    {
        throw new InvalidOperationException("Reset is not supported in Correlation Vector V2");
    }
}